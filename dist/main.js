(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["WorldEngine"] = factory();
	else
		root["WorldEngine"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/classes/BokehImageBuffer.js":
/*!*****************************************!*\
  !*** ./src/classes/BokehImageBuffer.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// TEST to use bokehfy to create animated walls\n// TODO: Don't let an opacity be set (no transparency)\n// TODO: If I can add in support of background images for bokehfy, I can use it as\n// an effect over normal game tiles!\nclass BokehImageBuffer {\n  constructor(bokehSettings = {}, sideLength = 200){\n    this.el = document.createElement('div');\n    this.settings = { ...bokehSettings, parent: this.el}\n    this.field = bokehfy(this.settings);\n    this.canvas = this.field.canvas;\n    this.width = this.canvas.width = sideLength;\n    this.height = this.canvas.height = sideLength;\n    this.ctx = this.canvas.getContext('2d');\n  }\n\n  getCanvas(){\n    // Because of the way bokehfy uses the parent of the bokeh field canvas as a barometer\n    // on resize events. We need to manually update the size here if it is 0 (ie a resize event has\n    // occured) before returning the image.\n    if(!this.canvas.width || !this.canvas.height){\n      this.canvas.width = this.width;\n      this.canvas.height = this.height;\n    }\n    return this.canvas;\n  }\n  \n  getImageData(){\n    return(this.ctx.getImageData(0,0, this.width, this.height));\n  }\n\n  trigger(){\n    return;\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (BokehImageBuffer);\n\n//# sourceURL=webpack://WorldEngine/./src/classes/BokehImageBuffer.js?");

/***/ }),

/***/ "./src/classes/Game.js":
/*!*****************************!*\
  !*** ./src/classes/Game.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Map */ \"./src/classes/Map.js\");\n/* harmony import */ var _Screen__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Screen */ \"./src/classes/Screen.js\");\n/* harmony import */ var _TextDisplay__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TextDisplay */ \"./src/classes/TextDisplay.js\");\n/* harmony import */ var _Player__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Player */ \"./src/classes/Player.js\");\n/* harmony import */ var _Vector__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Vector */ \"./src/classes/Vector.js\");\n/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utilities */ \"./src/utilities/index.js\");\n\n\n\n\n\n\n\n\n// TODO: Remove hardcoding\nconst STORAGE_ID = 'bb_raymarcher';\nconst SCREEN_WIDTH = 1024;\nconst SCREEN_HEIGHT = 768;\n\nclass Game {\n  constructor(maps, images, sprites, textureMap, framerate){\n    // We want to preserve the player's location when they are returning from an interaction\n    // that caused them to navigate away to a link.\n    const savedState = Object(_utilities__WEBPACK_IMPORTED_MODULE_5__[\"loadStateFromSessionStorage\"])(STORAGE_ID);\n    this.images = images;\n    this.interval = framerate;\n    this.animationFrame = null;\n\n    this.textureMap = textureMap;\n    this.sprites = sprites;\n    this.maps = maps;\n    // Gonna hardcode the first level for now. TODO: REMOVE\n    this.currentMap = savedState ? savedState.currentMap : this.maps[0];\n    this.grid = new _Map__WEBPACK_IMPORTED_MODULE_0__[\"default\"](this.currentMap.grid);\n\n    this.screen = new _Screen__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this, 'display-main', SCREEN_WIDTH, SCREEN_HEIGHT);\n\n    this.textDisplay = new _TextDisplay__WEBPACK_IMPORTED_MODULE_2__[\"default\"](Math.floor(SCREEN_WIDTH * .75), Math.floor(SCREEN_HEIGHT * .75))\n    this.textDisplay.write(\n      \"Welcome!\\n\\nUse WASD to move and spacebar\\nto interact with things.\\n\\n\\nFeel free to walk around and enjoy the sights.\\nMake yourself at home.\\nJust don't look in the basement, ever.\", \n      3500\n    );\n\n    this.player = savedState \n      ? new _Player__WEBPACK_IMPORTED_MODULE_3__[\"default\"](\n          this,\n          new _Vector__WEBPACK_IMPORTED_MODULE_4__[\"default\"](savedState.playerPos.x, savedState.playerPos.y), \n          new _Vector__WEBPACK_IMPORTED_MODULE_4__[\"default\"](savedState.playerDir.x, savedState.playerDir.y),\n          new _Vector__WEBPACK_IMPORTED_MODULE_4__[\"default\"](savedState.playerPlane.x, savedState.playerPlane.y)\n        )\n      : new _Player__WEBPACK_IMPORTED_MODULE_3__[\"default\"](\n          this, \n          new _Vector__WEBPACK_IMPORTED_MODULE_4__[\"default\"](this.currentMap.playerPos.x, this.currentMap.playerPos.y), \n          new _Vector__WEBPACK_IMPORTED_MODULE_4__[\"default\"](this.currentMap.playerDir.x, this.currentMap.playerDir.y),\n          new _Vector__WEBPACK_IMPORTED_MODULE_4__[\"default\"](this.currentMap.playerPlane.x, this.currentMap.playerPlane.y)\n        );\n\n    this.keyState = {}; // Active store of keypresses\n    document.addEventListener('keydown', ({ key }) => {\n      this.keyState[key] = true;\n    })\n    document.addEventListener('keyup', ({ key }) => {\n      this.keyState[key] = false;\n    })\n  }\n\n  start() {\n    let then = Date.now()\n    let delta;\n\n    const draw = timestamp => {\n      const now = Date.now(timestamp);\n      delta = now - then;\n      if(delta > this.interval) {\n        /* BEGIN Game Loop */\n        this.updatePlayerPositioning();\n        this.player.cast();      \n        this.drawScreen();\n        this.textDisplay.draw(this.screen);\n        /* END Game Loop */\n        then = now - (delta % this.interval)\n      }\n      this.animationFrame = requestAnimationFrame(draw);\n    }\n    this.animationFrame = requestAnimationFrame(draw)\n  }\n\n  updatePlayerPositioning(){\n    if(this.keyState['`']){\n      this.screen.showMap();\n    }\n    else {\n      this.screen.hideMap();\n    }\n    if(this.keyState.a){\n      this.player.rotate(1);\n    }\n    if(this.keyState.d){\n      this.player.rotate(-1);\n    }\n    if(this.keyState.w){\n      // if(this.keyState.Shift){\n      //   this.player.moveForward(1.5);\n      // }\n      // else {\n        this.player.moveForward();\n      // }\n    }\n    if(this.keyState.s){\n      this.player.moveBack();\n    }\n    if(this.keyState[' ']){\n      this.keyState[' '] = false;\n      this.player.trigger();\n    }\n  }\n\n  stop() {\n    cancelAnimationFrame(this.animationFrame)\n    this.animationFrame = null;\n  }\n\n  drawScreen(){\n    this.screen.draw();\n  }\n\n  saveStateToSessionStorageOnUnload(){\n    // We need a few things to restore the game (in its current form)\n    const state = {\n      playerPos: {\n        x: this.player.pos.x,\n        y: this.player.pos.y\n      },\n      playerDir: {\n        x: this.player.dir.x,\n        y: this.player.dir.y\n      },\n      playerPlane: {\n        x: this.player.plane.x,\n        y: this.player.plane.y\n      },\n      currentMap: this.currentMap\n    };\n    Object(_utilities__WEBPACK_IMPORTED_MODULE_5__[\"saveStatetoSessionStorage\"])(STORAGE_ID, state);\n  }\n\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Game);\n\n//# sourceURL=webpack://WorldEngine/./src/classes/Game.js?");

/***/ }),

/***/ "./src/classes/ImageBuffer.js":
/*!************************************!*\
  !*** ./src/classes/ImageBuffer.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nclass ImageBuffer {\n  constructor(image){\n    this.rawImage = image;\n    this.canvas = document.createElement('canvas');\n    this.width = this.canvas.width = this.rawImage.width;\n    this.height = this.canvas.height = this.rawImage.height;\n    this.ctx = this.canvas.getContext('2d');\n    this.ctx.drawImage(this.rawImage, 0, 0);\n    // Right now, getting the image data for textures on the fly can be really slow.\n    // We might be able to better take advantage of memory by doing it for all textures\n    // at the outset.\n    // If that's too much memory, we could do a mix. Certain texture's image data could be loaded\n    // up front and other's on the fly.\n    this.imageData = this.ctx.getImageData(0,0, this.width, this.height);\n  }\n\n  getCanvas(){\n    return this.canvas;\n  }\n\n  getImageData() {\n    return this.imageData;\n  }\n  \n  trigger(){\n    return;\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (ImageBuffer);\n\n//# sourceURL=webpack://WorldEngine/./src/classes/ImageBuffer.js?");

/***/ }),

/***/ "./src/classes/LinkImageBuffer.js":
/*!****************************************!*\
  !*** ./src/classes/LinkImageBuffer.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _ImageBuffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ImageBuffer */ \"./src/classes/ImageBuffer.js\");\n\n\nclass LinkImageBuffer extends _ImageBuffer__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n  constructor(href, image){\n    super(image)\n    this.href = href;\n  }\n\n  trigger(game){\n    // Instead of having to pass in the game object like this, we could broadcast events\n    game.saveStateToSessionStorageOnUnload();\n    window.location.href = this.href;\n    // We should also add in a highlight effect on elements that have a trigger function when in range, indicating they can\n    // be triggered.\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (LinkImageBuffer);\n\n//# sourceURL=webpack://WorldEngine/./src/classes/LinkImageBuffer.js?");

/***/ }),

/***/ "./src/classes/Map.js":
/*!****************************!*\
  !*** ./src/classes/Map.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nclass Map {\n  constructor(grid = []){\n    this.rawGrid = grid;\n    this.grid = this.temporaryCreateComplexGridObjects(this.rawGrid);\n    this.height = this.grid.length;\n    this.width = this.height ? this.grid[0].length : 0;\n  }\n\n  // In the future, a number of pieces of data will be useful to have\n  // attached to each cell in the grid, thus necessitating the use of objects\n  // over simple numbers. For a short period, we will continue to use basic textures\n  // but want the ability to add in a second property, whether a tile has been seen or not (for\n  // minimap rendering). So we'll dynamically generate the complex grid until we start hardcoding it.\n  temporaryCreateComplexGridObjects(grid){\n    return grid;\n  }\n\n  getCell(y, x){\n    if(this.grid[x][y] == null){\n      return null;\n    }\n    if(this.grid[x] == null){\n      return null;\n    }\n    return this.grid[x][y];\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Map);\n\n//# sourceURL=webpack://WorldEngine/./src/classes/Map.js?");

/***/ }),

/***/ "./src/classes/Player.js":
/*!*******************************!*\
  !*** ./src/classes/Player.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Vector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vector */ \"./src/classes/Vector.js\");\n\n\nconst checkIsFloor = cell => {\n  if(typeof cell === 'number' && cell === 0) {\n    return true;\n  }\n  if(cell.isFloor) {\n    return true;\n  }\n  return false;\n}\n\nclass Player {\n  constructor(game, pos, dir, plane){\n    this.game = game;\n    this.grid = this.game.grid;\n    this.pos = pos;\n    this.dir = dir;\n    this.plane = plane;\n    this.elevation = 1;\n    this.walkSpeed = .1;\n    this.rotationSpeed = .07;\n    this.elevationStep = .035;\n    // This only seems to be needed to be calculated once, unless the FOV changes.\n    this.inverseDeterminate = 1.0 / (this.plane.x * this.dir.y - this.dir.x * this.plane.y);\n\n    this.rays = [];\n    this.cast();\n  }\n  \n  // TODO: add in an early return for maximum cast distance\n  castRay(cameraX, castDistance = Infinity){\n    const rayDir = this.plane.scale(cameraX).add(this.dir);\n    const activeCell = this.pos.map(Math.floor);\n    \n    // The distance from the nearest cell walls\n    const distanceDelta = rayDir.map((scalar) => Math.abs(1 / scalar));\n    // Which way we're going.\n    const stepX = rayDir.x < 0 ? -1 : 1;\n    const stepY = rayDir.y < 0 ? -1 : 1;\n    \n    let sideDistX = (rayDir.x < 0 ? this.pos.x - activeCell.x : 1 + activeCell.x - this.pos.x) * distanceDelta.x;\n    let sideDistY = (rayDir.y < 0 ? this.pos.y - activeCell.y : 1 + activeCell.y - this.pos.y) * distanceDelta.y;\n    \n    // This assumes infinite draw distance and that all spaces will be fully enclosed\n    // TODO: Get rid of that assumption.\n    let wall = null;\n    // We don't really need the wall orientation since we can derive it from the face, but for now, we'll leave it in.\n    let wallOrientation;\n    // Where as for texture rendering, we just need to know if the wall is oriented horizontally\n    // or vertically, in order to do unique faces, we need to specify the wall orientation more granularly. ie cardinal.\n    // The orientation and the step direction should give this to us.\n    // There is no real cardinality to the map, but for now we'll use up === north, left === west. (where 0,0 is top left).\n    let wallFace;\n    while(!wall){\n      if(sideDistX < sideDistY){\n        sideDistX += distanceDelta.x;\n        activeCell.x += stepX;\n        wallOrientation = 0; // Vertical Wall\n        wallFace = stepX > 0 ? 'west' : 'east';\n      }\n      else {\n        sideDistY += distanceDelta.y;\n        activeCell.y += stepY;\n        wallOrientation = 1; // Horizontal Wall\n        wallFace = stepY > 0 ? 'north' : 'south';\n      }\n\n      const currentCell = this.grid.getCell(activeCell.x, activeCell.y);\n      if(currentCell == null){\n        break;\n      }\n      const isBasicWall = typeof currentCell === 'number' && currentCell > 0;\n      const isComplexWall = typeof currentCell === 'object' && currentCell != null && currentCell.isWall;\n      if(isBasicWall || isComplexWall){\n        wall = currentCell;\n      }\n    }\n\n    const normalizedDistance = wallOrientation === 0\n      ? (activeCell.x - this.pos.x + (1 - stepX) / 2) / rayDir.x\n      : (activeCell.y - this.pos.y + (1 - stepY) / 2) / rayDir.y\n    \n    // Exact intersection point with wall\n    const intersection = wallOrientation === 0\n      ? this.pos.y + normalizedDistance * rayDir.y\n      : this.pos.x + normalizedDistance * rayDir.x;\n\n    // This gives us the intersection relative to one wall unit.\n    const wallIntersection = intersection - Math.floor(intersection);\n    \n    const ray = {\n      normalizedDistance,\n      wall,\n      wallOrientation,\n      wallIntersection,\n      rayDir,\n      activeCell,\n      wallFace,\n    }\n\n    return ray;\n  }\n\n  cast(){\n    const rays = [];\n    // TODO: Create a raycaster class that Player calls. In the event we want to use the raycasting for non-player entities.\n    // TODO: Also so we can cast individual rays for things like shooting or triggering\n    // ----------------\n    // The idea here is to use ray marching to save intersection computations (in a small world this is more expensive than just calculating\n    // intersections with all objects, but in a massive world it's much cheaper (stable time in fact with a given limititation on drawdistance)).\n    // This is made possible because the walls are only drawn on grid vertices, which are at regular, predictable intervals.\n    // However, the player himself (and sprites later) will be at any valid vector (ie, not in a cell marked as a wall).\n    // So, before we start marching our rays up the gridlines, we first need to calculate the player's dx and dy relative to the closest grid \n    // line in the player dir.\n    const screenWidth = this.game.screen.width;\n    for(let i = 0; i < screenWidth; i++){\n      const cameraX = 2 * i / screenWidth - 1;\n      const ray = this.castRay(cameraX);\n      rays.push(ray);\n    }\n    this.rays = rays;\n  }\n\n  checkSpritesForCollisions(x,y){\n    const collisionDetected = this.game.sprites.some(sprite => {\n      if(!sprite.isSolid){\n        return false;\n      }\n\n      // TODO: We should move this calculating to a sprite method with just the player position passed.\n      const spriteX = sprite.pos.x;\n      const spriteY = sprite.pos.y;\n      const spriteBoundingBox = sprite.boundingBox;\n      // There will have to be a check for a bounding box, but for now we will assume there is and it is .2\n      const distance = Math.sqrt(Math.pow(x - spriteX, 2) + Math.pow(y - spriteY, 2));\n      const isColliding = (distance - spriteBoundingBox) < 0;\n      return isColliding;\n    });\n    return collisionDetected;\n  }\n\n  moveForward(modifier = 1){\n    // For now, the rule will simply be that players can only move through empty cells.\n    // In the future when cells become complex objects, we will need a traversable rule.\n    // (Things like sprites that are traversable)\n    // In fact, because sprites are likely going to be cell agnostic, until a better system is implemented,\n    // we'll likely have to iterate through all or most of them to check for collisions, regardless of their distance.\n    // Perhaps we can at least sort and filter them (only sprites that are x distance away).\n    // We likely won't use completely separate bounding boxes but instead draw a radius from the center of the sprite. \n    // So just checking if a sprite is within distancetosprite - spriteboundingboxradius is close to enough (there are of course\n    // issues with various angles of approach.)\n\n    // We need to check for collisions with sprite bounding boxes.\n    // For now, we are going to do this in a very dumb way.\n    // Per axis to allow sliding as above (though double the work!)\n    // a) For x movement, calculate new position.\n    // 1. Iterate through all sprites \n    // 2. For all sprites with isSolid: true, calculate distance to player. (non-normalized)\n    // 3. Determine if the distance is less than the sprites bounding box\n    // 4. If not, set new player pos.\n    // 5. Repeat for y.\n    \n    const newPosX = this.pos.x + this.dir.x * (this.walkSpeed * modifier);\n    const newPosY = this.pos.y + this.dir.y * (this.walkSpeed * modifier);\n    const cellX = Math.floor(newPosX);\n    const cellY = Math.floor(newPosY);\n    \n    // We split up moving along the axes to avoid getting stuck on walls\n    const nextCellX = this.grid.getCell(cellX, Math.floor(this.pos.y));\n    if(checkIsFloor(nextCellX)){\n      const collisionDetected = this.checkSpritesForCollisions(newPosX, this.pos.y);\n      if(!collisionDetected){\n        this.pos.x = newPosX;\n      }\n    }\n    const nextCellY = this.grid.getCell(Math.floor(this.pos.x), cellY);\n    if(checkIsFloor(nextCellY)){\n      const collisionDetected = this.checkSpritesForCollisions(this.pos.x, newPosY);\n      if(!collisionDetected){\n        this.pos.y = newPosY;\n      }\n    }\n  }\n\n  moveBack(){\n\n    const newPosX = this.pos.x - this.dir.x * this.walkSpeed;\n    const newPosY = this.pos.y - this.dir.y * this.walkSpeed;\n    const cellX = Math.floor(newPosX);\n    const cellY = Math.floor(newPosY);\n\n    // We split up moving along the axes to avoid getting stuck on walls\n    const nextCellX = this.grid.getCell(cellX, Math.floor(this.pos.y));\n    if(checkIsFloor(nextCellX)){\n      const collisionDetected = this.checkSpritesForCollisions(newPosX, this.pos.y);\n      if(!collisionDetected){\n        this.pos.x = newPosX;\n      }\n    }\n    const nextCellY = this.grid.getCell(Math.floor(this.pos.x), cellY);\n    if(checkIsFloor(nextCellY)){\n      const collisionDetected = this.checkSpritesForCollisions(this.pos.x, newPosY);\n      if(!collisionDetected){\n        this.pos.y = newPosY;\n      }\n    }\n  }\n\n  rotate(rotation){\n    // TODO: There's no reason these calls can't be lookup tables. The lookup tables can even be recalculated if the rotation\n    // speed changes.\n    const newDirX = this.dir.x * Math.cos(this.rotationSpeed * rotation) - this.dir.y * Math.sin(this.rotationSpeed * rotation);\n    const newDirY = this.dir.x * Math.sin(this.rotationSpeed * rotation) + this.dir.y * Math.cos(this.rotationSpeed * rotation);\n    const newPlaneX = this.plane.x * Math.cos(this.rotationSpeed * rotation) - this.plane.y * Math.sin(this.rotationSpeed * rotation);\n    const newPlaneY = this.plane.x * Math.sin(this.rotationSpeed * rotation) + this.plane.y * Math.cos(this.rotationSpeed * rotation);\n    this.dir = new _Vector__WEBPACK_IMPORTED_MODULE_0__[\"default\"](newDirX, newDirY);\n    this.plane = new _Vector__WEBPACK_IMPORTED_MODULE_0__[\"default\"](newPlaneX, newPlaneY);\n  }\n\n  trigger(){\n    const cameraX = 0; // Middle of the screen.w\n    const ray = this.castRay(cameraX);\n    const wallDistance = ray.normalizedDistance;\n    // The following would be to abstract into a separate sprite manager service. In a more-perfect world.\n    // Find closest sprite directly in front of player.\n    // Call it's trigger function.\n    // We'll need to sort for distance and check the zbuffer (just like with rendering and clipping) to get the closest sprite\n    // that is not behind a wall.\n    // Ideally we would check the strip of the sprite at the ceenter column and determine if all the pixels were transparent,\n    // but this is certainly overkill for now.\n    const sprites = this.game.sprites;\n    if(sprites.length > 0){\n      // Sort nearest to farthest, filtering any that are further away than the closest wall ($distance).\n      const closestUnobstructedSpriteWithTrigger = sprites.reduce((acc, sprite) => {\n        const spriteDistance = Math.pow(this.pos.x - sprite.pos.x, 2) + Math.pow(this.pos.y - sprite.pos.y, 2);\n        if(spriteDistance < wallDistance) {\n          const spriteX = sprite.pos.x;\n          const spriteY = sprite.pos.y;\n          const spriteX_relativeToPlayer = spriteX - this.pos.x;\n          const spriteY_relativeToPlayer = spriteY - this.pos.y;\n          \n          const transformX = this.inverseDeterminate * (this.dir.y * spriteX_relativeToPlayer - this.dir.x * spriteY_relativeToPlayer);\n          const transformY = Math.max(this.inverseDeterminate * (-this.plane.y * spriteX_relativeToPlayer + this.plane.x * spriteY_relativeToPlayer), 0);\n          \n          const spriteScreenX = Math.floor((this.game.screen.width / 2) * (1 + transformX / transformY));\n          // spriteScreenX gives us the center of the sprite on screen. But we also need to know the start and end. If the center of the screen is within that range\n          // then we have a potential target.\n          const widthRatio = (sprite.width / sprite.height) * sprite.scale;\n          const spriteWidth = Math.abs(Math.floor((this.game.screen.height / transformY * widthRatio)));\n          const drawStartX = Math.floor(-spriteWidth / 2 + spriteScreenX);\n          const drawEndX = spriteWidth / 2 + spriteScreenX;\n          const centerOfScreen = this.game.screen.width / 2;\n          if (centerOfScreen >= drawStartX && centerOfScreen <= drawEndX){\n            // Finally, we want to only take the closest, so we're going to cache that.\n            if(!acc.spriteDistance ){\n              // First match.\n              acc = {\n                spriteDistance,\n                sprite\n              }\n            }\n            else {\n              if(spriteDistance < acc.spriteDistance){\n                acc = {\n                  spriteDistance,\n                  sprite,\n                }\n              }\n            }\n          }\n        }\n        return acc;\n      }, {});\n\n      if(closestUnobstructedSpriteWithTrigger.sprite && closestUnobstructedSpriteWithTrigger.sprite.trigger != null){\n        // TODO: We can figure out what to pass it later. Possibly dynamically. For now, we'll give it the whole game instance!\n        closestUnobstructedSpriteWithTrigger.sprite.callTrigger(this.game);\n        // We don't want to trigger anything else, so let's hightail it.\n        return\n      }\n    \n    }\n\n    // This will be used for commands. For now, we'll have a rudimentary approach that just checks the cell directly\n    // in front of the player's direction to a very small maximum distance and call it's trigger function.\n    if(wallDistance < 1){\n      const wall = this.game.images[ray.wall - 1];\n      wall.trigger(this.game);\n    }\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Player);\n\n//# sourceURL=webpack://WorldEngine/./src/classes/Player.js?");

/***/ }),

/***/ "./src/classes/Screen.js":
/*!*******************************!*\
  !*** ./src/classes/Screen.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utilities */ \"./src/utilities/index.js\");\n\n\nconst PI2 = Math.PI * 2;\n\nconst HUES = {\n  1: '330',\n  2: '160',\n  3: '180',\n  4: '200',\n  5: '220',\n}\n\nconst tempFloorTextureCanvas = document.createElement('canvas');\ntempFloorTextureCanvas.width = 64;\ntempFloorTextureCanvas.height = 64;\nconst tempFloorTexture = tempFloorTextureCanvas.getContext('2d');\nfor(let i = 0; i < tempFloorTextureCanvas.width; i += 8){\n  tempFloorTexture.fillStyle = `hsl(${i * 5}, 100%, 80%)`;\n  tempFloorTexture.fillRect(i,0, 8,64);\n}\n\n// While the API is unstable around walls and textures, we'll abstract away as much as we can\n// into helpers.\nconst getWallCellTextureCode = (cell, wallFace) => {\n  if(typeof cell === 'number') {\n    return cell;\n  }\n  if(typeof cell === 'object' && cell != null && cell.isWall) {\n    if (wallFace && cell.faces != null) {\n      const faceTexture = cell.faces[wallFace];\n      if(Number.isInteger(faceTexture)) {\n        return faceTexture; \n      }\n    }\n    return cell.defaultTexture;\n  }\n}\n\n/**\n * \n * @param {string} id The DOM id of the canvas element this screen instance wraps.\n */\nclass Screen {\n  constructor(game, mainScreenCanvasId, width, height){\n    this.canvas = document.getElementById(mainScreenCanvasId);\n    this.ctx = this.canvas.getContext('2d');\n    this.canvasBuffer = document.createElement('canvas');\n    this.ctxBuffer = this.canvasBuffer.getContext('2d');\n    this.floorBuffer = document.createElement('canvas');\n    this.floorCtxBuffer = this.floorBuffer.getContext('2d');\n    this.canvas.width = this.canvasBuffer.width = this.width = width;\n    this.canvas.height = this.canvasBuffer.height = this.height = height;\n    this.offscreenCanvasPixels;\n    this.backgroundColor = 'black';\n    this.game = game;\n    this.currentMap = this.game.currentMap;\n    // We delay creating the background until after the main canvas size is determined.\n    // TODO: We could also generate this only as needed, if it seems like it adds too much memory.\n    this.staticPOVBackgroundCanvasBuffer = document.createElement('canvas');\n    this.staticPOVBackgroundCtxBuffer = this.staticPOVBackgroundCanvasBuffer.getContext('2d');\n    // Use this for a singleton pattern to avoid redrawing the sky gradient on each frame.\n    this.hasDrawnSkyGradient = false;\n    // Just to make sure the canvas is reset before beginning.\n    // When this is true, draw minimap overlay.\n    // TODO: Can have all conditional render options set as single object with getters/setters later. (HUD, etc)\n    this.isMapActive = false;\n\n    // Create constants to speed up the casting\n    this.CENTER_Y = this.height / 2;\n    // Create lookup tables to speed up the casting.\n    this.lookupCurrentDist = this.generateCurrentDistLookupTable();\n    this.lookupFloorBrightnessModifier = this.generateFloorBrightnessModifierLookupTable();\n  }\n\n  generateSkyGradient(stops){\n    this.hasDrawnSkyGradient = true;\n    const gradient = this.staticPOVBackgroundCtxBuffer.createLinearGradient(0,0,0, this.height / 2);\n    Object(_utilities__WEBPACK_IMPORTED_MODULE_0__[\"applyColorStopsToLinearGradient\"])(gradient, stops);\n    this.staticPOVBackgroundCtxBuffer.fillStyle = gradient;\n    this.staticPOVBackgroundCtxBuffer.fillRect(0, 0, this.width, this.height / 2);\n  }\n\n  generateCurrentDistLookupTable(){\n    const table = {};\n    for(let i = this.CENTER_Y; i < this.height; i++){\n      table[i] = this.height / (2.0 * i - this.height)\n    }\n    return table;\n  }\n\n  generateFloorBrightnessModifierLookupTable(){\n    const table = {};\n    // Since we know dead center of the screen is the darkest possible and we want a fall off, we can use \n    // an inverse square law.\n    // Let's say that the maximum drop off is 50% brightness. That means brightness is 1 / dist.\n    for(let i = this.CENTER_Y; i < this.height; i++){\n      const distanceFromPlayer = ((this.height - i) / this.CENTER_Y) * 1.1;\n      const brightnessModifier = 1 / Math.pow(2, distanceFromPlayer);\n      table[i] = brightnessModifier;\n    }\n    return table;\n  }\n\n  initializeOffscreenCanvasPixels(){\n    if(!this.offscreenCanvasPixels){\n      this.floorBuffer.width = this.width;\n      this.floorBuffer.height = this.height;\n      this.offscreenCanvasPixels = this.floorCtxBuffer.getImageData(0,0,this.width, this.height);\n    }\n  }\n  \n  updateFromBuffer(){\n    this.ctx.drawImage(this.canvasBuffer, 0,0);\n  }\n\n  // ### Getters/Setters\n\n  showMap(){\n    this.isMapActive = true;\n  }\n\n  hideMap(){\n    this.isMapActive = false;\n  }\n\n  toggleMap(){\n    this.isMapActive = !this.isMapActive;\n  }\n\n  // ### Display Helpers\n\n  resizeCanvas(width, height) {\n    this.canvas.width = this.canvasBuffer.width = this.width = width;\n    this.canvas.height = this.canvasBuffer.height = this.height = height;\n  }\n\n  setBackgroundColor(color) {\n    this.backgroundColor = color;\n  }\n\n  // ### Main draw functions\n\n  drawMapOverlay(){\n    // TODO: Lots of hardcoded stuff to make dynamic.\n    const emptyCellColor = 'rgba(5,5,5,0.7)';\n    // TODO: For simplicity's sake, we'll hard code the placement and size of the minimap for now at the top left.\n    // Probably would be nicer as a full screen overlay with transparency;\n    const mapLeft = 0;\n    const mapTop = 0;\n    const mapWidth = 200;\n    const mapHeight = 200;\n    const mapXRatio = mapWidth / this.game.grid.width;\n    const mapYRatio = mapHeight / this.game.grid.height;\n    // Get player position and direction\n    const playerPos = this.game.player.pos;\n    const playerDir = this.game.player.dir;\n    const playerSize = 3;\n    // Get current world map.\n    // This will be a class with useful methods... later\n    const world = this.game.grid;\n    const mapGrid = world.grid;\n    const GRID_UNIT = 1;\n    const mapWidthUnit = mapXRatio * GRID_UNIT;\n    const mapHeightUnit = mapYRatio * GRID_UNIT;\n\n    // Render grid lines\n    for (let i = 0; i <= world.width; i++){\n      // VERTICAL\n      this.ctxBuffer.beginPath();\n      this.ctxBuffer.lineWidth = 1;\n      this.ctxBuffer.strokeStyle = 'rgba(255,255,255,0.3)';\n      this.ctxBuffer.moveTo(0 + (i * mapWidthUnit), 0);\n      this.ctxBuffer.lineTo(0 + (i * mapWidthUnit), mapHeight);\n      this.ctxBuffer.closePath();\n      this.ctxBuffer.stroke();\n    }\n    \n    for(let i = 0; i < world.height; i++){\n      // HORIZONTAL\n      this.ctxBuffer.beginPath();\n      this.ctxBuffer.lineWidth = 1;\n      this.ctxBuffer.strokeStyle = 'rgba(255,255,255,0.3)';\n      this.ctxBuffer.moveTo(0, 0 + (i * mapHeightUnit));\n      this.ctxBuffer.lineTo(mapWidth, 0 + (i * mapHeightUnit));\n      this.ctxBuffer.closePath();\n      this.ctxBuffer.stroke();\n    }\n\n    // TODO: Fix the mirrored orientation issues!!!\n    // Render grid elements, scaled.\n    for(let rowOffset = 0; rowOffset < mapGrid.length; rowOffset++){\n      const row = mapGrid[rowOffset];\n      for(let columnOffset = 0; columnOffset < row.length; columnOffset++){\n        const reversedRowOffset = mapGrid.length - 1 - rowOffset;\n        const reversedColumnOffset = row.length - 1 - columnOffset;\n        const cell = world.getCell(rowOffset, columnOffset);\n        const textureId = cell; // In the future the cell will have more data so this will require extracing the data\n        const cellHue = HUES[textureId];\n        const cellTexture = this.game.images[cell - 1] && this.game.images[cell - 1].getCanvas();\n        const cellLeft = rowOffset * mapWidthUnit;\n        const cellTop = columnOffset * mapHeightUnit;\n        if (cellTexture){\n          this.ctxBuffer.drawImage(cellTexture, 0, 0, cellTexture.width, cellTexture.height, cellLeft, cellTop, mapWidthUnit, mapHeightUnit);\n        }\n        else {\n          this.ctxBuffer.beginPath();\n          this.ctxBuffer.fillStyle = cellHue ? `hsla(${cellHue}, 100%, 80%, .9)` : emptyCellColor;\n          this.ctxBuffer.fillRect(cellLeft, cellTop, mapWidthUnit, mapHeightUnit);\n          this.ctxBuffer.closePath();\n        }\n      } \n    }\n\n    // Render player dot\n    const playerPosXOnMap = playerPos.x * mapXRatio;\n    const playerPosYOnMap = playerPos.y * mapYRatio;\n    this.ctxBuffer.beginPath();\n    this.ctxBuffer.fillStyle = 'red';\n    this.ctxBuffer.arc(playerPosXOnMap, playerPosYOnMap, playerSize, 0, PI2);\n    this.ctxBuffer.fill();\n  }\n\n  /**\n   * Since all levels will have at least a default floor texture we only\n   * need to concern ourselves with the sky/upper half.\n   * \n   * We want to allow for several levels of fallbacks when it comes to the sky.\n   * \n   * If a level has a sky texture, use that.\n   * Else if a level has a gradient use that.\n   * Else use a hardcoded default color (or in the future a generated one based on the default floor texture (a darker color perhaps)).\n   */\n  drawPOVBackground(){\n    const backgroundImageTextureKey = this.game.currentMap.skyTexture;\n    const backgroundImage = this.game.textureMap[backgroundImageTextureKey];\n    if(backgroundImage){\n      // We need to have an origin for the image\n      // We need to find the offset from that origin in the FOV and then sample 1/6 of the image\n      // from that point then draw it to the background.\n      const { x, y } = this.game.player.dir;\n      const angle = Math.atan2(x, y);\n      let degrees = angle > 0 ? Object(_utilities__WEBPACK_IMPORTED_MODULE_0__[\"toDegrees\"])(angle) : 360 + Object(_utilities__WEBPACK_IMPORTED_MODULE_0__[\"toDegrees\"])(angle);\n      // degrees = degrees - 30 >= 0 ? degrees - 30 : 360 + degrees - 30;\n      const sampleWidth = backgroundImage.width / 6;// 1/3 of image because FOV / 180\n      const currentSampleStart = (degrees / 360) * backgroundImage.width;\n      const willOverflow = (backgroundImage.width - currentSampleStart) < sampleWidth;\n      if(willOverflow){\n        const overflowWidth = (currentSampleStart + sampleWidth) - backgroundImage.width;\n        const nonOverflowWidth = sampleWidth - overflowWidth;\n        const overflowRatio = nonOverflowWidth / sampleWidth;\n        const seamPoint = overflowRatio * this.width;\n        // We need to get the two pieces separately and stitch them together on a new canvas.\n        // In the case where we are too close to the edges, we need to sample the overflow from the head or tail\n        // to create the seam.\n        this.ctxBuffer.drawImage(backgroundImage.canvas, currentSampleStart, 0, nonOverflowWidth, backgroundImage.height, 0, 0, seamPoint, this.height)\n        this.ctxBuffer.drawImage(backgroundImage.canvas, 0, 0, overflowWidth, backgroundImage.height, seamPoint, 0, this.width - seamPoint, this.height)\n      }\n      else {\n        this.ctxBuffer.drawImage(backgroundImage.canvas, currentSampleStart, 0, sampleWidth, backgroundImage.height, 0, 0, this.width, this.height)\n      }\n    }\n    else {\n      const skyGradientGradientStops = this.game.currentMap.skyGradient;\n      const fallbackGradientStops = [{ stop: 0, color: '#6190E8'}, { stop: 1, color: '#A7BFE8'}];\n      const stops = skyGradientGradientStops && skyGradientGradientStops.length > 0 \n                      ? skyGradientGradientStops \n                      : fallbackGradientStops;\n      if(!this.hasDrawnSkyGradient){\n        this.generateSkyGradient(stops);\n      }\n      this.ctxBuffer.drawImage(this.staticPOVBackgroundCanvasBuffer, 0, 0, this.width, this.height / 2);\n    }\n  }\n\n  drawPlayerPOV(){\n    const { rays, elevation: playerElevation } = this.game.player;\n    // We'll need to record the perpendicular distance of each column for sprite clipping later.\n    const zBuffer = [];\n\n    if(!rays){\n      return;\n    }\n    for(let i = 0; i < rays.length; i++){\n      const ray = rays[i];\n      // TODO: Make ray class to abstract and use getters.\n      const { normalizedDistance, wall, wallOrientation, wallIntersection, rayDir, activeCell, wallFace } = ray;\n\n      zBuffer.push(normalizedDistance);\n\n      const columnHeight = Math.ceil(this.height / normalizedDistance);\n      const top = (this.height / 2) - (columnHeight / 2) * playerElevation;\n      const VIEW_DISTANCE = 25;\n      const brightnessMultiplier = 1.3;\n      const darknessMultiplier = 0.9;\n      const brightness = (((VIEW_DISTANCE - (normalizedDistance * brightnessMultiplier)) / VIEW_DISTANCE) * 40) + 10; // clamps the brightness between 10 and 50.\n      \n      // If a texture doesn't exist, use a fallback color\n      // Must support both types of walls, simple numbers and objects.\n      const wallTextureCode = getWallCellTextureCode(wall, wallFace);\n      const wallTexture = wallTextureCode && this.game.images[wallTextureCode - 1] && this.game.images[wallTextureCode - 1].getCanvas();\n      if(wallTexture){\n        const textureWidth = wallTexture.width;\n        let wallIntersectionOffset;\n        if(wallOrientation === 1){\n          if(this.game.player.dir.y > 0){\n            wallIntersectionOffset = wallIntersection - Math.floor(wallIntersection);\n          }\n          else {\n            wallIntersectionOffset = 1 - (wallIntersection - Math.floor(wallIntersection));\n          }\n        }\n        else {\n          if(this.game.player.dir.x < 0){\n            wallIntersectionOffset = wallIntersection - Math.floor(wallIntersection);\n          }\n          else {\n            wallIntersectionOffset = 1 - (wallIntersection - Math.floor(wallIntersection));\n          }\n        }\n        let textureStripLeft = Math.floor(wallIntersectionOffset * textureWidth);\n        this.ctxBuffer.drawImage(wallTexture, textureStripLeft, 0, 1, wallTexture.height, i, top, 1, columnHeight);\n        // TODO: HANDLE HEIGHTS IN MULTIPLES OF ONE (FOR NOW)\n        // Hardcoding a height of two temporarily.\n        if (typeof wall === 'object' && wall.height > 1) {\n          // This doesn't really work because it only renders correctly face on. \n          // Getting this to work would require keeping the DDA algorithm going past initial intersections with walls and then using a zBuffer of sorts to\n          // draw with a painters algorithm. I'm starting to rethink the utility of that.\n          this.ctxBuffer.drawImage(wallTexture, textureStripLeft, 0, 1, wallTexture.height, i, top - columnHeight, 1, columnHeight);\n        }\n\n        // TODO: Change this to color shift the pixels directly instead of messing with a semi-opaque overlay.\n        this.ctxBuffer.fillStyle = 'black';\n        this.ctxBuffer.globalAlpha = 1 - (VIEW_DISTANCE - (normalizedDistance * darknessMultiplier)) / VIEW_DISTANCE;\n        this.ctxBuffer.fillRect(i, top, 1, columnHeight);\n        this.ctxBuffer.globalAlpha = 1;\n      }\n      else {\n        const wallHue = HUES[wall] || 0; // Anything without a fallback hue will be crazy red and obvious.\n        const hsl = `hsl(${ wallHue }, 100%, ${ brightness }%)`;\n        this.ctxBuffer.fillStyle = hsl;\n        this.ctxBuffer.beginPath();\n        this.ctxBuffer.fillRect(i,top, 1, columnHeight);\n        this.ctxBuffer.closePath();\n      }\n      // This creates artificial shading on half the vertices to give them extra three dimensional feel.\n      if(wallOrientation === 1){\n        this.ctxBuffer.globalAlpha = .2;\n        this.ctxBuffer.fillStyle = 'black';\n        this.ctxBuffer.fillRect(i, top, 1, columnHeight);\n        this.ctxBuffer.globalAlpha = 1;\n      }\n\n      // #### FLOOR CASTING\n\n      let floorXWall;\n      let floorYWall;\n      //4 different wall directions possible\n      if(wallOrientation === 0 && rayDir.x > 0) {\n        floorXWall = activeCell.x;\n        floorYWall = activeCell.y + wallIntersection;\n      }\n      else if(wallOrientation === 0 && rayDir.x < 0) {\n        floorXWall = activeCell.x + 1.0;\n        floorYWall = activeCell.y + wallIntersection;\n      }\n      else if(wallOrientation === 1 && rayDir.y > 0) {\n        floorXWall = activeCell.x + wallIntersection;\n        floorYWall = activeCell.y;\n      }\n      else {\n        floorXWall = activeCell.x + wallIntersection;\n        floorYWall = activeCell.y + 1.0;\n      }\n\n      // draw the floor from columnBottom to the bottom of the screen\n      const columnBottom = Math.floor(top + columnHeight) >= 0 ? Math.floor(top + columnHeight) : this.height;\n      const floorColumnHeight = this.height - columnBottom;\n\n      if(floorColumnHeight > 0){\n        for(let y = columnBottom; y < this.height; y++){\n          const x = i;\n          const currentDist = this.lookupCurrentDist[y];\n          const weight = currentDist / normalizedDistance;\n\n          const currentFloorX = weight * floorXWall + (1.0 - weight) * this.game.player.pos.x;\n          const currentFloorY = weight * floorYWall + (1.0 - weight) * this.game.player.pos.y;\n          const gridCell = this.currentMap.grid[Math.floor(currentFloorY)][Math.floor(currentFloorX)];\n\n          // Until all textures are complex cells, we need to handle simple integers or objects.\n          let floorTexture, ceilingTexture = null;\n          if(typeof gridCell === 'number'){\n            floorTexture = this.game.images[gridCell];\n          }\n          else {\n            if (gridCell.floorTexture != null) {\n              floorTexture = this.game.images[gridCell.floorTexture - 1];\n            }\n            if (gridCell.ceilingTexture != null) {\n              ceilingTexture = this.game.images[gridCell.ceilingTexture - 1];\n            }\n          }\n\n          // ### DRAW FLOOR\n          if (floorTexture != null){\n            const floorTexturePixels = floorTexture.getImageData();\n  \n            const floorTexX = Math.floor(currentFloorX * floorTexture.width) % floorTexture.width;\n            const floorTexY = Math.floor(currentFloorY * floorTexture.height) % floorTexture.height;\n            const textureIndex = (floorTexY * floorTexture.width + floorTexX) * 4;\n  \n            // Let's dim the floor\n            // TODO: Better dropoff curve.\n            const brightnessModifier = this.lookupFloorBrightnessModifier[y];\n  \n            const red = floorTexturePixels.data[textureIndex] * brightnessModifier;\n            const green = floorTexturePixels.data[textureIndex + 1] * brightnessModifier;\n            const blue = floorTexturePixels.data[textureIndex + 2] * brightnessModifier;\n            const alpha = floorTexturePixels.data[textureIndex + 3];\n  \n            const index = (y * this.width + x) * 4;\n            this.offscreenCanvasPixels.data[index] = red;\n            this.offscreenCanvasPixels.data[index + 1] = green;\n            this.offscreenCanvasPixels.data[index + 2] = blue;\n            this.offscreenCanvasPixels.data[index + 3] = alpha;\n          }\n\n          // ### DRAW CEILING\n          if (ceilingTexture) {\n            const ceilingTexturePixels = ceilingTexture.getImageData();\n\n            const ceilTexX = Math.floor(currentFloorX * ceilingTexture.width) % ceilingTexture.width;\n            const ceilTexY = Math.floor((this.height - currentFloorY) * ceilingTexture.height) % ceilingTexture.height;\n            const textureIndex = (ceilTexY * ceilingTexture.width + ceilTexX) * 4;\n  \n            // Let's dim the ceiling more than the floor.\n            // TODO: Better dropoff curve.\n            const brightnessModifier = this.lookupFloorBrightnessModifier[y] - .2;\n  \n            const red = ceilingTexturePixels.data[textureIndex] * brightnessModifier;\n            const green = ceilingTexturePixels.data[textureIndex + 1] * brightnessModifier;\n            const blue = ceilingTexturePixels.data[textureIndex + 2] * brightnessModifier;\n            const alpha = ceilingTexturePixels.data[textureIndex + 3];\n  \n            const index = ((this.height - y) * this.width + x) * 4;\n            this.offscreenCanvasPixels.data[index] = red;\n            this.offscreenCanvasPixels.data[index + 1] = green;\n            this.offscreenCanvasPixels.data[index + 2] = blue;\n            this.offscreenCanvasPixels.data[index + 3] = alpha;\n  \n          }\n        }        \n      }\n    }\n    // Because of the mix of direct pixel manipulation and drawImage calls, we have dangling bits of render\n    // code like this for the nonce.\n    this.floorCtxBuffer.putImageData(this.offscreenCanvasPixels, 0, 0);\n    this.ctxBuffer.drawImage(this.floorBuffer,0,0);\n    this.floorCtxBuffer.clearRect(0,0, this.floorBuffer.width, this.floorBuffer.height)\n    this.offscreenCanvasPixels = this.floorCtxBuffer.getImageData(0,0,this.width, this.height);\n\n    // #### SPRITE RENDERING\n    // We'll also need to sort out the sizing of textures. I'm inclined to say they should all be the same height but variable widths.\n    const sprites = this.game.sprites;\n\n    // TODO: In the future we could have a visible property to allow us to persist objects in the world that\n    // might be temporarily hidden.\n    if(sprites.length > 0){\n\n      // Sort sprites by dumb distance (not normalized).\n      const sortedSprites = sprites.sort((sprite1, sprite2) => {\n        const sprite1distance = Math.pow(this.game.player.pos.x - sprite1.pos.x, 2) + Math.pow(this.game.player.pos.y - sprite1.pos.y, 2);\n        const sprite2distance = Math.pow(this.game.player.pos.x - sprite2.pos.x, 2) + Math.pow(this.game.player.pos.y - sprite2.pos.y, 2);\n        return sprite2distance - sprite1distance;\n      })\n\n      for(let i = 0; i < sortedSprites.length; i++){\n        const currentSprite = sortedSprites[i];\n        if(currentSprite){\n          const spriteX = currentSprite.pos.x;\n          const spriteY = currentSprite.pos.y;\n          const spriteX_relativeToPlayer = spriteX - this.game.player.pos.x;\n          const spriteY_relativeToPlayer = spriteY - this.game.player.pos.y;\n          \n          const transformX = this.game.player.inverseDeterminate * (this.game.player.dir.y * spriteX_relativeToPlayer - this.game.player.dir.x * spriteY_relativeToPlayer);\n          // This provides the depth on screen, much like a z-index in a 3d system.\n          // Depth will of course we used to determine size, height, vertical offset, and wall clipping.\n          // NOTE TO SELF: The Math.max is used to clamp to zero. For some reason, planck-length level numbers were being created\n          // at a very specific location which caused the program to hang as it looped through insane ranges.\n          const transformY = Math.max(this.game.player.inverseDeterminate * (-this.game.player.plane.y * spriteX_relativeToPlayer + this.game.player.plane.x * spriteY_relativeToPlayer), 0);\n          \n          const spriteScreenX = Math.floor((this.width / 2) * (1 + transformX / transformY));\n          // using \"transformY\" instead of the real distance prevents fisheye\n          const scale = currentSprite.scale;\n          const spriteHeight = Math.abs(Math.floor(this.height / transformY) * scale);\n          \n          // calculate lowest and highest pixel to fill in current stripe\n          const drawStartY = Math.floor((-spriteHeight * currentSprite.verticalOffset) / 2 + this.height / 2);\n          const drawEndY = spriteHeight + drawStartY;\n          \n          //calculate width of the sprite\n          // The width ratio ensures the sprite is not stretched horizontally.\n          const widthRatio = (currentSprite.width / currentSprite.height) * scale;\n          const spriteWidth = Math.abs(Math.floor((this.height / transformY * widthRatio )));\n          const drawStartX = Math.floor(-spriteWidth / 2 + spriteScreenX);\n          const drawEndX = spriteWidth / 2 + spriteScreenX;\n          \n          // Draw sprite in vertical strips.\n          for(let stripe = drawStartX; stripe < drawEndX; stripe++){\n            const texX = Math.floor(256 * (stripe - (-spriteWidth / 2 + spriteScreenX)) * currentSprite.width / spriteWidth) / 256;\n            //the conditions in the if are:\n            //1) it's in front of camera plane so you don't see things behind you\n            //2) it's on the screen (left)\n            //3) it's on the screen (right) \n            //4) ZBuffer, with perpendicular distance\n            if(transformY > 0 && stripe > 0 && stripe < this.width && transformY < zBuffer[stripe]) {\n              // TODO: When sprites are multifaceted, we'll need to pass in player pos/dir to calculate the face;\n              this.ctxBuffer.drawImage(currentSprite.getFrame(), texX, 0, 1, currentSprite.height, stripe, drawStartY, 1, drawEndY - drawStartY);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  draw() {\n    // We don't bother with a clrScreen function because, between the sky, floor textures, and walls, it's moot.\n    this.drawPOVBackground();\n    this.initializeOffscreenCanvasPixels();\n    this.drawPlayerPOV();\n    if(this.isMapActive){\n      this.drawMapOverlay();\n    }\n    this.updateFromBuffer();\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Screen);\n\n//# sourceURL=webpack://WorldEngine/./src/classes/Screen.js?");

/***/ }),

/***/ "./src/classes/Sprite.js":
/*!*******************************!*\
  !*** ./src/classes/Sprite.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Vector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vector */ \"./src/classes/Vector.js\");\n\n\n/**\n * A sprite defines a wrapper around a spritesheet\n * and the wrapping object. To be later separated.\n */\nclass Sprite {\n  constructor(textureMap, spriteConfig){\n    // This class was originally going to wrap the spritesheet (to make\n    // it easier to pull off specific locations and handle issues with proportional scaling.)\n    // TODO: Create spritesheet class.\n    this.spritesheet = textureMap[spriteConfig.spritesheet];\n    this.pos = new _Vector__WEBPACK_IMPORTED_MODULE_0__[\"default\"](spriteConfig.pos.x, spriteConfig.pos.y);\n    this.type = spriteConfig.type;\n    this.isSolid = spriteConfig.isSolid;\n    this.isMultifaceted = spriteConfig.isMultifaceted;\n    this.isAnimated = spriteConfig.isAnimated;\n    this.trigger = spriteConfig.trigger;\n\n    // TODO: The height might need to be calculated dynimcally. For now we'll just\n    // use the spritesheet dimensions (since we only have single frame sprites as of now)\n    this.scale = spriteConfig.scale ? spriteConfig.scale : 1;\n    this.height = this.spritesheet.height;\n    this.width = this.spritesheet.width;\n\n    this.verticalOffset = spriteConfig.verticalOffset ? spriteConfig.verticalOffset : 1;\n\n    // TODO: The dynamic setups should be done more dynamically, natch.\n    if(this.isSolid){\n      this.boundingBox = spriteConfig.boundingBox;\n    }\n    if(this.isMultifaceted){\n      // Load faces etc.\n      this.dir = new _Vector__WEBPACK_IMPORTED_MODULE_0__[\"default\"](spriteConfig.dir);\n    }\n    if(this.isAnimated){\n      // Deal with controllers, paths, subscribe to animation loops etc.\n    }\n  }\n\n  getFrame(){\n    // TODO: When we start having multifaceted sprites, there will have to be\n    // additional calculations. For now we can just return the full imagebuffer of the spritesheet.\n    return this.spritesheet.getCanvas();\n  }\n\n  // TODO: We're going to dynamically generate trigger functions using the config trigger object settings.\n  // We'll need to validate later of course to make sure called methods are available.\n  callTrigger(game){\n    const { type: triggerFunction, ...settings } = this.trigger;\n    // TODO: Add in validation method exists beyond just being a function.\n    if(typeof this[triggerFunction] === 'function'){\n      this[triggerFunction](game, settings);\n    }\n  }\n\n  // TODO: We should broadcast messages instead of directly calling the textdisplay instance.\n  showText(game, { text }){\n    game.textDisplay.write(text, 2000);\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Sprite);\n\n//# sourceURL=webpack://WorldEngine/./src/classes/Sprite.js?");

/***/ }),

/***/ "./src/classes/TextDisplay.js":
/*!************************************!*\
  !*** ./src/classes/TextDisplay.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/**\n * This will hopefully get a lot more refined as time goes on.\n * \n * For now, the idea is for this class to have its own buffer. Events can be triggered that\n * will be written here and blitted to the screen at the end of a frame's render.\n * \n * Temporary:\n *  - We're going to hard code a timer to self-expire the messages. \n *  - New messages will blow away old ones and start a new timer.\n *  - Hard code the width of the text display.\n * \n * Enhancements:\n *  - Create a quick fade out animation.\n *  - Create a flag that saves render cycles by only rendering when the text display is visible.\n */\nclass TextDisplay {\n  constructor(width, height){\n    this.canvas = document.createElement('canvas');\n    this.ctx = this.canvas.getContext('2d');\n    this.width = this.canvas.width = width;\n    this.height = this.canvas.height = height;\n    this.isVisible = false;\n    this.timeout = null;\n  }\n\n  draw(screen){\n    if(this.isVisible){\n      const top = (screen.height / 2) - (this.height / 2);\n      const left = (screen.width / 2) - (this.width / 2);\n      screen.ctx.drawImage(this.canvas, 0, 0, this.width, this.height, left, top, this.width, this.height);\n    }\n  }\n\n  clear(){\n    this.isVisible = false;\n  }\n  \n  write(text, time = 4000){\n    // In case one write call happens before another expires.\n    clearTimeout(this.timeout);\n    this.isVisible = true;\n    this._write(text);\n    this.timeout = setTimeout(this.clear.bind(this), time);\n  }\n  \n  _write(text = ''){\n    this.ctx.clearRect(0,0,this.width, this.height);\n    // We want to allow line breaks.\n    const lines = text.split('\\n');\n    // We'll need to figure out how to calculate the right offset for positioning and line spacing.\n    // For now we'll assume the 20px font size.\n    const lineCount = lines.length;\n    // Font properties should be on the class properties and be settable.\n    const textSize = 30;\n\n    const textBlockTop = (this.height / 2) - (Math.ceil(lineCount / 2) * textSize)\n    for(let i = 0; i < lines.length; i++){\n      const lineTop = textBlockTop + (textSize * i);\n      const lineText = lines[i];\n      this.ctx.fillStyle = 'white';\n      this.ctx.font = `${textSize}px Roboto`;\n      this.ctx.textAlign = \"center\";\n      this.ctx.fillText(lineText, this.width / 2, lineTop);\n    }\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (TextDisplay);\n\n//# sourceURL=webpack://WorldEngine/./src/classes/TextDisplay.js?");

/***/ }),

/***/ "./src/classes/Vector.js":
/*!*******************************!*\
  !*** ./src/classes/Vector.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nclass Vector {\n  constructor(x = 0, y = 0) {\n    this.x = x;\n    this.y = y;\n  }\n\n  add(vector){\n    return new Vector(this.x + vector.x, this.y + vector.y);\n  }\n\n  scale(scalar){\n    return new Vector(this.x * scalar, this.y * scalar);\n  }\n\n  cross(vector){\n\n  }\n\n  dot(vector){\n\n  }\n\n  map(callback){\n    return new Vector(callback(this.x), callback(this.y));\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Vector);\n\n//# sourceURL=webpack://WorldEngine/./src/classes/Vector.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _classes_ImageBuffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./classes/ImageBuffer */ \"./src/classes/ImageBuffer.js\");\n/* harmony import */ var _classes_LinkImageBuffer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./classes/LinkImageBuffer */ \"./src/classes/LinkImageBuffer.js\");\n/* harmony import */ var _classes_BokehImageBuffer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./classes/BokehImageBuffer */ \"./src/classes/BokehImageBuffer.js\");\n/* harmony import */ var _classes_Sprite__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./classes/Sprite */ \"./src/classes/Sprite.js\");\n/* harmony import */ var _classes_Game__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./classes/Game */ \"./src/classes/Game.js\");\n/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utilities */ \"./src/utilities/index.js\");\n\n\n\n\n\n\n// This approach is going to use a different tack then the last one. Instead of using a direction angle we'll\n// use a direction vector. We can then step along rays in increments of that vector.\n\n// In addition, we'll also use a camera plane.\n\n// TODO: Loading screen\n// TODO: Create a name for any tiles that might not have one. Or is this necessary? Without\n// a name, how can we specify them in the improved map anyway?\n\nconst loadImageBuffer = async ({ path }) => {\n  const img = await Object(_utilities__WEBPACK_IMPORTED_MODULE_5__[\"loadImage\"])(path);\n  const imageBuffer = new _classes_ImageBuffer__WEBPACK_IMPORTED_MODULE_0__[\"default\"](img);\n  return imageBuffer;\n}\n\nconst loadImageBuffer2 = async (path) => {\n  const img = await Object(_utilities__WEBPACK_IMPORTED_MODULE_5__[\"loadImage\"])(path);\n  const imageBuffer = new _classes_ImageBuffer__WEBPACK_IMPORTED_MODULE_0__[\"default\"](img);\n  return imageBuffer;\n}\n\nconst loadLinkImageBuffer = async ({ href, path }) => {\n  const img = await Object(_utilities__WEBPACK_IMPORTED_MODULE_5__[\"loadImage\"])(path);\n  const linkImageBuffer = new _classes_LinkImageBuffer__WEBPACK_IMPORTED_MODULE_1__[\"default\"](href, img);\n  return linkImageBuffer;\n}\n\nconst loadBokeh = ({ bokehSettings }) => {\n  return new _classes_BokehImageBuffer__WEBPACK_IMPORTED_MODULE_2__[\"default\"](bokehSettings);\n}\n\nconst loadTiles = tiles => {\n  return Promise.all(tiles.map(tile => {\n    switch(tile.type){\n      case 'image':\n        return loadImageBuffer(tile)\n      case 'bokeh':\n        return Promise.resolve(loadBokeh(tile));\n      case 'link-image':\n        return loadLinkImageBuffer(tile)\n      default:\n        break;\n    }\n  }));\n}\n\nconst loadTextures = async (texturePaths) => {\n  const textureMap = {};\n  for(let i = 0; i < texturePaths.length; i++){\n    const path = texturePaths[i];\n    const pathParts = path.split('/');\n    const fileNameAndExtension = pathParts[pathParts.length - 1];\n    const fileName = fileNameAndExtension.split('.')[0];\n\n    const texture = await loadImageBuffer2(path);\n    \n    textureMap[fileName] = texture;\n  }\n  return textureMap;\n}\n\n// The sprite textures will be stored in a hash for named reference.\nconst loadSprites = sprites => Promise.all(sprites.map((sprite) => {\n  return loadImageBuffer(sprite);\n  // This will change soon of course to support a unique sprite class.\n}))\n\n// Depending on how things shake out, instead of putting these into a map, we might just want\n// to create a map of several arrays based on the sprite type (object, NPC etc.) since \n// certain operations will be called on each depending on that. So, solid sprites will be\n// called for collision detection, animated sprites will be called for updating in the game loop, etc.\nconst loadSprites2 = textureMap => spriteConfigs => {\n  // TODO: Don't build sprites that don't have required properties (esp pos and spritesheet).\n  const sprites = spriteConfigs.map(config => new _classes_Sprite__WEBPACK_IMPORTED_MODULE_3__[\"default\"](textureMap, config));\n  return sprites;\n}\n\nconst FRAMERATE = 1000 / 30;\n\n// Instead of wrapping the game, we could wrap each level with a loader so that asset loads are lighter.\nconst main = async (wad) => {\n  const textureMap = await loadTextures(wad.textures);\n  const sprites = loadSprites2(textureMap)(wad.sprites);\n  const tiles = await loadTiles(wad.tiles);\n  const maps = wad.maps;\n  const game = new _classes_Game__WEBPACK_IMPORTED_MODULE_4__[\"default\"](maps, tiles, sprites, textureMap, FRAMERATE);\n  game.start();\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (main);\n\n//# sourceURL=webpack://WorldEngine/./src/index.js?");

/***/ }),

/***/ "./src/utilities/index.js":
/*!********************************!*\
  !*** ./src/utilities/index.js ***!
  \********************************/
/*! exports provided: toDegrees, loadImage, applyColorStopsToLinearGradient, loadStateFromSessionStorage, saveStatetoSessionStorage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toDegrees\", function() { return toDegrees; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"loadImage\", function() { return loadImage; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"applyColorStopsToLinearGradient\", function() { return applyColorStopsToLinearGradient; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"loadStateFromSessionStorage\", function() { return loadStateFromSessionStorage; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"saveStatetoSessionStorage\", function() { return saveStatetoSessionStorage; });\n// # Helper functions\n\n// const toRadians = degrees => degrees * (Math.PI / 180);\n// const vectorDistance = (vector1, vector2) => Math.sqrt((vector1.x - vector2.x) ** 2 + (vector1.y - vector2.y) ** 2);\n// const random = (upper = 100, lower = 0) => Math.max(Math.floor(Math.random() * (upper + 1)), lower);\n// const clamp = (number, min, max) => Math.max(min, Math.min(number, max));\n// const getMovementDelta = ({angle, forward = true, speed = .5 }) => {\n//   const rads = toRadians(angle);\n//   const xDelta = Math.cos(rads) * speed;\n//   const yDelta = Math.sin(rads) * speed;\n//   const x = forward ? xDelta : -xDelta;\n//   const y = forward ? yDelta : -yDelta;\n//   return { x, y };\n// }\n// const scaleToScreen = (vector, screen) => {\n//   const scaleX = screen.width / MAP_WIDTH;\n//   const scaleY = screen.height / MAP_HEIGHT;\n//   const scaledX = vector.x * scaleX;\n//   const scaledY = vector.y * scaleY;\n//   return { x: scaledX, y: scaledY };\n// }\nconst toDegrees = radians => radians / (Math.PI/ 180);\nconst loadImage = path => {\n  return new Promise((resolve, reject) => {\n    const img = document.createElement('img');\n    img.addEventListener('load', () => {\n      resolve(img);\n    })\n    img.src = path;\n  })\n}\nconst applyColorStopsToLinearGradient = (linearGradient, stops) => {\n  for(let i = 0; i < stops.length; i++){\n    linearGradient.addColorStop(stops[i].stop, stops[i].color)\n  }\n}\n\nconst loadStateFromSessionStorage = storageId => {\n  try {\n      const serializedState = sessionStorage.getItem(storageId);\n      if(serializedState === null) {\n          return undefined;\n      }\n      const state = JSON.parse(serializedState);\n      // Clear sessionStorage so that refreshes restart a level\n      sessionStorage.removeItem(storageId);\n      return state;\n  }\n  catch(err) {\n      return undefined;\n  }\n}\n\nconst saveStatetoSessionStorage = (storageId, currentState) => {\n  try {\n      const serializedState = JSON.stringify(currentState);\n      sessionStorage.setItem(storageId, serializedState)\n  }\n  catch(err) {\n      console.log(err);\n  }\n}\n\n//# sourceURL=webpack://WorldEngine/./src/utilities/index.js?");

/***/ })

/******/ });
});